import * as Lavalink from '@lavaclient/types/v3';
import { TrackInfo, FilterData, EqualizerBand, Filter, PlayerEvent, PlayData, TrackEndReason } from '@lavaclient/types/v3';
import { TypedEmitter } from 'tiny-typed-emitter';
import { Pool, Dispatcher } from 'undici';

declare const _socket: unique symbol;
declare const _reconnectionPromise: unique symbol;
declare class Connection {
    readonly node: Node;
    readonly info: ConnectionInfo;
    static CLIENT_NAME: string;
    reconnectTry: number;
    payloadQueue: OutgoingPayload[];
    connectedAt?: number;
    clientName: string;
    private [_reconnectionPromise]?;
    private [_socket]?;
    constructor(node: Node, info: ConnectionInfo);
    get active(): boolean;
    get canReconnect(): boolean;
    get uptime(): number;
    send(important: boolean, data: Lavalink.OutgoingMessage): Promise<void>;
    connect(): void;
    disconnect(code?: number, reason?: string): void;
    configureResuming(): Promise<void>;
    flushQueue(): void;
    reconnect(): Promise<boolean>;
    private _onopen;
    private _onclose;
    private _onerror;
    private _onmessage;
    private _send;
}
declare type ReconnectDelay = (current: number) => number | Promise<number>;
interface ConnectionInfo {
    host: string;
    port: number;
    password: string;
    secure?: boolean;
    resuming?: ResumingOptions;
    reconnect?: ReconnectOptions;
    clientName?: string;
}
interface ResumingOptions {
    key: string;
    timeout?: number;
}
interface ReconnectOptions {
    delay?: number | ReconnectDelay;
    tries?: number;
}
interface OutgoingPayload {
    resolve: () => void;
    reject: (error: Error) => void;
    data: Lavalink.OutgoingMessage;
}

declare enum NodeState {
    Idle = 0,
    Connecting = 1,
    Connected = 2,
    Disconnecting = 3,
    Disconnected = 4,
    Reconnecting = 5
}

declare class REST {
    readonly node: Node;
    readonly pool: Pool;
    constructor(node: Node);
    private get info();
    get baseUrl(): string;
    loadTracks(identifier: string): Promise<Lavalink.LoadTracksResponse>;
    decodeTracks(...tracks: string[]): Promise<Lavalink.DecodeTracksResponse>;
    decodeTrack(track: string): Promise<Lavalink.DecodeTrackResponse>;
    do<T>(endpoint: string, { method, data }?: Options): Promise<T>;
}
interface Options {
    method?: Dispatcher.HttpMethod;
    data?: any;
}

declare class Node extends TypedEmitter<NodeEvents> {
    static DEBUG_FORMAT: string;
    static DEBUG_FORMAT_PLAYER: string;
    static DEFAULT_STATS: Lavalink.StatsData;
    readonly players: Map<string, Player<this>>;
    readonly conn: Connection;
    readonly rest: REST;
    readonly sendGatewayPayload: SendGatewayPayload;
    state: NodeState;
    stats: Lavalink.StatsData;
    userId?: Snowflake;
    constructor(options: NodeOptions);
    get penalties(): number;
    connect(user?: Snowflake | DiscordResource | undefined): void;
    createPlayer(guild: Snowflake | DiscordResource): Player<this>;
    destroyPlayer(guild: Snowflake | DiscordResource): Promise<boolean>;
    handleVoiceUpdate(update: VoiceStateUpdate | VoiceServerUpdate): Promise<void>;
    debug(topic: string, message: string, player?: Player): void;
}
declare type SendGatewayPayload = (id: Snowflake, payload: {
    op: 4;
    d: Dictionary;
}) => void;
interface NodeEvents {
    connect: (event: ConnectEvent) => void;
    disconnect: (event: DisconnectEvent) => void;
    closed: () => void;
    error: (error: Error) => void;
    debug: (message: string) => void;
    raw: (message: Lavalink.IncomingMessage) => void;
}
interface ConnectEvent {
    took: number;
    reconnect: boolean;
}
interface DisconnectEvent {
    code: number;
    reason: string;
    reconnecting: boolean;
    wasClean: boolean;
}
interface NodeOptions extends ManagerOptions {
    connection: ConnectionInfo;
}

declare class ClusterNode extends Node {
    readonly cluster: Cluster;
    readonly id: string;
    constructor(cluster: Cluster, id: string, info: ConnectionInfo);
    emit<U extends keyof NodeEvents>(event: U, ...args: Parameters<NodeEvents[U]>): boolean;
}

declare class Cluster extends TypedEmitter<ClusterEvents> {
    readonly nodes: Map<string, ClusterNode>;
    readonly sendGatewayPayload: SendGatewayPayload;
    userId?: Snowflake;
    constructor(options: ClusterOptions);
    get rest(): REST | null;
    get idealNodes(): ClusterNode[];
    connect(user?: Snowflake | DiscordResource | undefined): void;
    createPlayer(guild: Snowflake | DiscordResource, nodeId?: string): Player<ClusterNode>;
    getPlayer(guild: Snowflake | DiscordResource): Player<ClusterNode> | null;
    destroyPlayer(guild: Snowflake | DiscordResource): Promise<boolean>;
    handleVoiceUpdate(update: VoiceServerUpdate | VoiceStateUpdate): Promise<boolean>;
    getNode(guild: Snowflake | DiscordResource): ClusterNode | null;
}
interface ClusterEvents {
    nodeConnect: (node: ClusterNode, event: ConnectEvent) => void;
    nodeDisconnect: (node: ClusterNode, event: DisconnectEvent) => void;
    nodeError: (node: ClusterNode, error: Error) => void;
    nodeDebug: (node: ClusterNode, message: string) => void;
    nodeRaw: (node: ClusterNode, message: Lavalink.IncomingMessage) => void;
}
interface ClusterOptions extends ManagerOptions {
    nodes: ClusterNodeOptions[];
}
interface ClusterNodeOptions extends ConnectionInfo {
    id: string;
}

declare type Manager = Node | Cluster;
declare type Dictionary<V = any, K extends string | symbol = string> = Record<K, V>;
declare type Snowflake = string;
interface DiscordResource {
    id: Snowflake;
}
interface ManagerOptions {
    sendGatewayPayload: SendGatewayPayload;
    user?: Snowflake | DiscordResource;
}
declare function getId(value: Snowflake | DiscordResource): Snowflake;
declare function randomId(): Snowflake;

declare const _voiceUpdate: unique symbol;
declare const _volume: unique symbol;
declare class Player<N extends Node = Node> extends TypedEmitter<PlayerEvents> {
    readonly node: N;
    static USE_FILTERS: boolean;
    readonly guildId: Snowflake;
    channelId: string | null;
    track?: string;
    trackData?: TrackInfo;
    playing: boolean;
    playingSince?: number;
    paused: boolean;
    connected: boolean;
    filters: Partial<FilterData>;
    lastPosition?: number;
    lastUpdate?: number;
    private [_voiceUpdate];
    private [_volume];
    constructor(node: N, guild: Snowflake | DiscordResource);
    get accuratePosition(): number | undefined;
    get position(): number | undefined;
    get volume(): number;
    connect(channel: Snowflake | DiscordResource | null, options?: ConnectOptions): this;
    disconnect(): this;
    play(track: string | {
        track: string;
    }, options?: PlayOptions): Promise<this>;
    stop(): Promise<this>;
    pause(state?: boolean): Promise<this>;
    resume(): Promise<this>;
    seek(position: number): Promise<this>;
    destroy(): Promise<this>;
    setVolume(volume: number): Promise<this>;
    setEqualizer(...gains: number[]): Promise<this>;
    setEqualizer(...bands: EqualizerBand[]): Promise<this>;
    setFilters(): Promise<this>;
    setFilters(filters: FilterData): Promise<this>;
    setFilters<F extends Filter>(filter: F, data: FilterData[F]): Promise<this>;
    handleVoiceUpdate(update: VoiceStateUpdate | VoiceServerUpdate): Promise<boolean>;
    handleEvent(event: PlayerEvent): void;
}
declare type PlayOptions = Omit<PlayData, "track">;
interface PlayerEvents {
    disconnected: (code: number, reason: string, byRemote: boolean) => void;
    trackStart: (track: string) => void;
    trackEnd: (track: string | null, reason: TrackEndReason) => void;
    trackException: (track: string | null, error: Error) => void;
    trackStuck: (track: string | null, thresholdMs: number) => void;
    channelJoin: (joined: Snowflake) => void;
    channelLeave: (left: Snowflake) => void;
    channelMove: (from: Snowflake, to: Snowflake) => void;
}
interface ConnectOptions {
    deafened?: boolean;
    muted?: boolean;
}
interface VoiceServerUpdate {
    token: string;
    endpoint: string;
    guild_id: `${bigint}`;
}
interface VoiceStateUpdate {
    session_id: string;
    channel_id: `${bigint}` | null;
    guild_id: `${bigint}`;
    user_id: `${bigint}`;
}

declare class DataInput {
    private readonly buf;
    private readonly view;
    private pos;
    constructor(data: Uint8Array | string);
    readByte(): number;
    readBoolean(): boolean;
    readUnsignedShort(): number;
    readInt(): number;
    readLong(): bigint;
    readUTF(): string;
    private advance;
}

declare const TRACK_INFO_VERSIONED = 1;
declare const TRACK_INFO_VERSION = 2;
declare const decoders: Record<number, TrackInfoDecoder>;
declare function decode(data: Uint8Array | string): DecodedTrackInfo | null;
declare type DecodedTrackInfo = TrackInfo & {
    version: number;
    probeInfo: {
        name: string;
        parameters?: string;
    };
};
declare type TrackInfoDecoder = (input: DataInput) => DecodedTrackInfo | null;

export { Cluster, ClusterEvents, ClusterNode, ClusterNodeOptions, ClusterOptions, ConnectEvent, ConnectOptions, Connection, ConnectionInfo, DecodedTrackInfo, Dictionary, DisconnectEvent, DiscordResource, Manager, ManagerOptions, Node, NodeEvents, NodeOptions, NodeState, Options, OutgoingPayload, PlayOptions, Player, PlayerEvents, REST, ReconnectDelay, ReconnectOptions, ResumingOptions, SendGatewayPayload, Snowflake, TRACK_INFO_VERSION, TRACK_INFO_VERSIONED, TrackInfoDecoder, VoiceServerUpdate, VoiceStateUpdate, decode, decoders, getId, randomId };
